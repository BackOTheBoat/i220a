  		      P r o j e c t   2

*Due*: Mar 16, by midnight.

This document first provides the aims of this project, followed by a
discussion of its background.  It then lists the requirements as explicitly
as possible.  It then hints at how these requirements can be met.  Finally,
it describes exactly what needs to be submitted.


			Aims
			====

The aims of this project are as follows:

  + To give you more exposure to bit twiddling.

  + To give you some familiarity with writing code which uses character
    pointers.


    	      	     Background
		     ==========

The unsigned and 2's complement representations covered in class are
only some of the many ways integers can be represented using bits.  
Another alternative is binary-coded-decimal BCD (<http://en.wikipedia.org/wiki/Binary-coded_decimal>).  

BCD representation is straightforward: each decimal digit is
represented using a single "nybble" (4-bits) with the binary-encoding
of the digit being the straight-forward bit-encoding of that digit.  Successive digits are encoded using successive nybble's.

Examples of encodings: (we show the BCD encoding in both hex and
decimal; for interest, we also show a binary encoding).

   ====================================================================
   Decimal Representation	BCD Encoding		Binary Encoding
   >------------------------>---------------------->-------------------
        798			0x798 (1944)		0x31e
	123			0x123 (291)		0x7b
	98765                   0x98765 (624485)	0x181cd
   ====================================================================

			Requirements
			============

Given your name as "FIRST" "LAST", create and submit a
`gzip`-compressed `tar` archive `prj2-`"LAST"`_`"FIRST"`.tar.gz` such
that unpacking that archive into some directory and typing `make`
within that directory will build a single program named `bcd`.

When invoked simply as `bcd`, the program must read lines from standard
input.

  + If the line contains a single non-negative decimal integer, then
    the program must print a line containing the string representation
    of the BCD representation of that integer, followed in parentheses
    by the decimal value of the BCD representation of the integer when
    that representation is interpreted as usual binary.

  + If the line contains 2 non-negative decimal integers separated by
    a `+` character and the sum of the two integers is `sum`, then the
    program must print a line containing the string representation of
    the BCD representation of `sum`, followed in parentheses by the
    decimal value of the BCD representation of `sum` when that
    representation is interpreted as usual binary.


  + If the line contains 2 non-negative decimal integers separated by
    a `*` character and the product of the two integers is `prod`,
    then the program must print a line containing the string
    representation of the BCD representation of `prod`, followed in
    parentheses by the decimal value of the BCD representation of
    `prod` when that representation is interpreted as usual binary.

  + If the contents of the line does not match any of the above, then
    the program should signal an appropriate error and continue
    processing its standard input.

It is assumed that a BCD integer fits within an unsigned long.  If any
of the above inputs overflow that representation, then the results are
undefined.

The above program *must* be implemented using a `bcd` module which
meets the following specification:

------------------------------------------------------------
/** Representation used for a BCD number */
typedef unsigned long Bcd;

/** Return BCD encoding of decimal number corresponding to string s.
 *  Sets p to point to the first non-digit character in s.  Behavior
 *  undefined on overflow.  Rougly equivalent to strtol().
 */
Bcd str_to_bcd(const char *s, const char **p);

/** Convert bcd to string in buf.  Never write more than bufSize
 *  characters into buf.  The return value is the number of characters
 *  written (excluding the NUL character used to terminate strings).
 *
 *  If the output is truncated due to the bufSize limit, then the
 *  return value is the number of characters (excluding the
 *  terminating null byte) which would have been written to the final
 *  string if enough space had been available. Thus, a return value of
 *  bufSize or more means that the output was truncated.
 */
int bcd_to_str(Bcd bcd, char *buf, int bufSize);

/** Return the BCD representation of the sum of BCD int's x and y.  Ignore
 *  overflow.
 */
Bcd bcd_add(Bcd x, Bcd y);

/** Return the BCD representation of the product of BCD int's x and y.
 *  Ignore overflow.
 */
Bcd bcd_multiply(Bcd x, Bcd y);
------------------------------------------------------------

You may make the following assumptions:

  + Assume that the character encoding for the digit-characters is
    such that the value of the digit represented by digit-character
    `c` is `c - '0'`.

  + Assume that an input line does not exceed 80 characters (including
    the terminating newline and `NUL` characters).
    
	     	 	 Provided Files
			 ==============

The files (<./files>) directory contains a Makefile
(<./files/Makefile>) which can be used to build your project as well
as produce the archive needed for submission.  It assumes that the
`bcd` module corresponds to specification file `bcd.h` and
implementation file `bcd.c`.  It assumes a main program driver in
`main.c`.  If you use a different organization, then
you will need to change the `Makefile`.

Simply typing `make` should build the project; typing `make dist`
should build the gzip-compressed `tar`-archive which needs to be
submitted.

Minimally, you must edit the `Makefile` to provide your first and
last names so that the submitted archive has the correct name.

			Example Log
			===========

Here is an annotated log of your program.  It first gives some
examples of error checking.  Annotations extend from `#` to
end-of-line.

------------------------------------------------------------
$ ./bcd
			#empty line could be signalled as an error
0 (0)			#instead of treated as 0.
123/
bad input 123/
-123
bad input -123
123+4+3
bad input 123+4+3
1234
1234 (4660)		#string representation of bcd is identical
     			#to decimal representation of input.
1234+666
1900 (6400)
333*3
999 (2457)
926*4
3704 (14084)
1342+9999
11341 (70465)
1342*9999
13418658 (323061336)
------------------------------------------------------------

			Hints
			=====

The following points are not prescriptive in that you may choose to ignore
them as long as you meet all the project requirements.

  0. Make sure you understand BCD representation.  It may also be a
     good idea to review manual methods for addition and (long) 
     multiplication.

  1. Setup the Makefile (<./files/Makefile>).  Minimally, you will
     need to complete the `make`-macros which define your name.

  2. Start the `bcd` module by copying its specifications into a
     `bcd.h` header file (protected against multiple inclusion with
     the usual idiom) and start a `bcd.c` implementation file.

  3. It may be a good idea to define some utility routines:

     ------------------------------------------------------------
     /** Return the value of BCD digit at index i in bcd (with the 
      *  least significant digit at index 0).
      */
     static unsigned get_bcd_digit(Bcd bcd, unsigned i);

     /** Set the value of BCD digit at index i in bcd to v (with the
      *  least significant digit at index 0).
      */
     static Bcd set_bcd_digit(Bcd bcd, unsigned i, unsigned v);
     ------------------------------------------------------------


  4. Define the `str_to_bcd()` routine.  Use a pointer to scan the
     string as long as it is pointing to a digit-character (use
     `isdigit()` from `<ctype.h>`).  For each digit-character
     accumulate it's decimal value in a BCD integer (using the
     previously implemented `set_bcd_digit()`).  Make sure that
     the pointer argument to the routine is updated to point
     to the first non-digit-character.

  5. Define the `bcd_to_str()` routine.  Note that the string
     representation can be produced by using `printf`'s `%x`
     format-specifier on the BCD representation.  Overflow of the
     buffer can be avoided by using `snprintf()`.

  6. Start the main program in `main.c`.  Have a loop which reads and
     processes lines.  For now assume that lines contain only a single
     integer which you feed into `str_to_bcd()` and print out the BCD
     using `bcd_to_str()`.  Use `fgets()` to continue reading lines
     from standard input until `EOF`.

  7. Write the `bcd_add()` routine.  Use the addition algorithm you
     learnt in elementary school: add digit by digit propagating a
     carry if necessary.  If the binary sum of 2 BCD digits is `sum`,
     you can get the resulting BCD digit as `sum % 10` and the carry
     as `sum / 10`.

  8. In preparation for the multiplication, it may be a good idea
     to write a routine which multiplies a BCD representation by
     a single BCD digit (in [0, 9]):

     ------------------------------------------------------------
     /** Return Bcd representation of result of multiply BCD x by BCD
      *  digit bcdDigit (in [0, 9]).
      */
     static Bcd bcd_multiply_digit(Bcd x, unsigned bcdDigit);
     ------------------------------------------------------------

  9.  Implement `bcd_multiply()`.  Use the long-multiplication
      algorithm you learnt in elementary school.  Initialize an
      accumulating result to 0.  For each digit in the multiplier,
      multiply the multiplicand by it (using `bcd_multiply_digit()`)
      and then add the result (suitably shifted) to the accumulating
      result.

  10. Iterate the previous steps until you meet all the project requirements.

			Submission
			==========

Besides the files needed to build your project, you *must* also
include a `README` file which minimally contains your name and
B-number.  Additionally, it can contain the following:

  + The status of your program (especially, if not fully complete).

  + A description of how your code works, if that is not completely clear
    by reading the code (note that this should not be necessary, ideally
    your code should be self-documenting).

  + Possibly a log of test cases which work and which don't work.

  + Any other material you believe is relevant to the grading of your
    project.

Before submitting your distribution, test it by unpacking it into an empty
directory, typing `make` in that directory and confirming that your
freshly built executable works.

Send an email to the TA at <mailto:haygan1@binghamton.edu> containing
your `prj2-`"LAST"`_`"FIRST"`.tar.gz` source distribution as an
*attachment*.  The archive should *not* contain any object or
executable files.  The subject line of the email must be set to `CS
220B: Project 2`.

